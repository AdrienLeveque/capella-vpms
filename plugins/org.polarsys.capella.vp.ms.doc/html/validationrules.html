<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<link rel="stylesheet" type="text/css" href="PLUGINS_ROOT/org.polarsys.capella.doc/html/styles.css" media="all" />
	</head>
	<body>
		<h1 id="Validation_Rules">Validation Rules</h1>
		<p>The Modes &amp; States viewpoint does not include validation rules that help to ensure the consistency of configurations, e.g. that a configuration references only elements that are in its scope, or that a configuration only references configurations of subcomponents as its child configurations. Such rules will be delivered in a subsequent version.
			However, the prototype includes several new validation rules related to State Machines:</p>
		<p>
			<b>DWF_SM_16</b> - A Mode/State has at least one incoming transition.
			When designing an FSM, it is important that all Mode/State has at least one incoming transition. In fact, if no such transition exists, the Mode/State is said unreachable.
		</p>
		<p>
			<b>DWF_SM_17</b> - There exists at least two outgoing transition from a Fork Pseudo-State.
			A Fork Pseudo-State serves to split an incoming transition into two or more transitions.
		</p>
		<p>
			<b>DWF_SM_18</b> - There exists at least two incoming transition to a Join Pseudo-State.
			A Join Pseudo-State serves to merge several transitions.
		</p>
		<p>
			<b>DWF_SM_19</b> - Into a region, there exists no more than one Initial Pseudo-State.
			There is no more than one Initial Pseudo-State into a Region.
		</p>
		<p>
			<b>DWF_SM_20</b> - There exists at least one transition starting from an Initial Pseudo-State.
			Into a region with an Initial Pseudo-State, there exists at least one transition starting from this Initial Pseudo-State.
		</p>
		<p>
			<b>DWF_SM_21</b> - There exists at most one transition starting from an Initial Pseudo-State.
			Into a region with an Initial Pseudo-State, there exists at most one transition starting from this Initial Pseudo-State.
		</p>
		<p>
			<b>DWF_SM_22</b> - Outgoing transitions of a Pseudo-State should not have a trigger.
			Outgoing transitions of a Pseudo-State should not have a trigger.
		</p>
		<p>
			<b>DWF_SM_23</b> - There exists at least two outgoing transition from a Choice Pseudo-State.
			There exists at least two outgoing transition from a Choice Pseudo-State.
		</p>
		<p>
			<b>DWF_SM_24</b> - Outgoing transitions from a Fork Pseudo-State should not have Guard.
			Outgoing transitions from a Fork Pseudo-State should not have Guard.
		</p>
		<p>
			<b>DWF_SM_25</b> - Incoming transitions to a Join Pseudo-State should not have Guard.
			Incoming transitions to a Join Pseudo-State should not have Guard.
		</p>
		<p>
			<b>DWF_SM_26</b> - Transitions starting from Initial Pseudo-States cannot have Guard.
			Transitions starting from Initial Pseudo-States cannot have Guard.
		</p>
		<p>
			<b>DWF_SM_27</b> - Limit the number of inclusions of M/Ss into M/Ss to 3 levels.
			Limit the number of inclusions of M/Ss into M/Ss to 3 levels.
		</p>
		<p>
			<b>DWF_SM_28</b> - A Mode/State has at least one outgoing transition.
			When designing an FSM, it is important that all Mode/State have at least one outgoing transition. In fact, if no such transition exists, the Mode/State is said blocking state.
		</p>
		<p>
			<b>DWF_SM_29</b> - Incoming transitions to a Join Pseudo-State should not have Trigger.
			Incoming transitions to a Join Pseudo-State should not have Trigger.
		</p>
		<p>
			<b>DWF_SM_30</b> - Into a region, there exists at least one Initial Pseudo-State.
			There is at least one one Initial Pseudo-State into a Region.
		</p>
		<p>
			<b>DWF_SM_31</b> - At least one M/S of the component FSMs has this function set as available.
			Let consider a function allocated to a component. If an FSM is linked to this component, then at least one M/S of this FSM has this function set as available.
		</p>
		<p>
			<b>DWF_SM_32</b> - The function involved by the ‘do activity’ of the M/S has to be available in this M/S or in the M/S of the higher level (if existing).
			The function involved by the ‘do activity’ of the M/S has to be available in this M/S or in the M/S of the higher level (if existing).
		</p>
		<p>
			<b>DWF_SM_33</b> - All functions of a ‘functional chain’ should be allocated to a component if this functional chain is set available into a M/S of a FSM linked to this component.
			A functional chain can be set available into a M/S of an FSM linked to a component, only if all functions of this functional chains are allocated to this component.
		</p>
		<p>
			<b>DWF_SM_34</b> - The first element into the lifeline of a component should be a M/S if at least one FSM is linked to this component.
			Within an exchange scenario, for the lifeline of a component for which an FSM is linked, one of the following is required:
		</p>
		<ul>
			<li>Either the first object put into this lifeline is a M/S (of this FSM).</li>
			<li>Or the diagram’s pre-condition defines the first M/S of the considered lifeline.</li>
		</ul>
		<p>
			<b>DWF_SM_35</b> - Between two consecutive M/Ss placed on a lifeline, there exists a path of transitions between these M/Ss.
			Within an exchange scenario, between two consecutive M/Ss placed on a lifeline, there exists a path of transitions between these M/Ss.
		</p>
		<p>
			<b>DWF_SM_36</b> - The functional exchange trigger of two consecutive M/Ss has to be added between these two M/Ss in the lifeline.
			Within an exchange scenario, let consider two consecutive M/Ss put in a lifeline with an existing transition triggered by a functional exchange; if the lifeline of the architectural part (i.e.: another component or an actor), for which the function starting the functional exchange, is present into the exchange scenario; this functional exchange has to be added between these two M/Ss.
		</p>
		<p>
			<b>DWF_SM_38</b> - Target M/Ss of outgoing transitions from a Fork Pseudo-State must have to be in a distinct region than the Fork Pseudo-State.
			Target M/Ss of outgoing transitions from a Fork Pseudo-State must have to be in a distinct region than the Fork Pseudo-State.
		</p>
		<p>
			<b>DWF_SM_39</b> - Outgoing transitions from a Fork Pseudo-State must target M/Ss into distinct regions of an orthogonal state.
			Outgoing transitions from a Fork Pseudo-State must target M/Ss into distinct regions of an orthogonal state.
		</p>
		<p>
			<b>DWF_SM_40</b> - Source M/Ss of incoming transitions to a Join Pseudo-State must have to be in a distinct region than the Join Pseudo-State.
			Source M/Ss of incoming transitions to a Join Pseudo-State must have to be in a distinct region than the Join Pseudo-State.
		</p>
		<p>
			<b>DWF_SM_41</b> - Incoming transitions to a Join Pseudo-State must originate from M/Ss into different regions of an orthogonal state.
			Incoming transitions to a Join Pseudo-State must originate from M/Ss into different regions of an orthogonal state.
		</p>
		<p>
			<b>DWF_SM_42</b> - Final State should not include a Region.
			Final State should not include a Region.
		</p>
		<p>
			<b>DWF_SM_43</b> - Generate global modes of the system and then analyze the configurations availability.
			Generate global modes of the system and then analyze the configurations availability in these global modes. Not a true ‘validation’, has rather informational purpose.
		</p>
		<p>
			<b>DWF_SM_44</b> - No inclusion of modes into states.
			The inclusion of modes into states is not allowed.
		</p>
		<p>
			<b>DWF_SM_45</b> - No inclusion of states into modes .
			The inclusion of states into modes is not allowed.
		</p>
		<p>
			<b>DWF_SM_50</b> - Element are included and excluded by CSConfiguration.
			Element are included and excluded by CSConfiguration.
		</p>
		<p>
			<b>DWF_SM_52</b> - Realising configuration

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_53</b> - irregular realization between layer

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_60</b> - Analysis of the comparison element completeness

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_61</b> - Analysis of the comparison element correctness

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_62</b> - Analysis of the comparison element consistency

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_63</b> - Analysis of the comparison element consistency

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_90</b> - Analysis of the situation element construction (completeness and correctness)

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_95</b>
			Compare each configuration or situation and check if they contain the same functions.
		</p>
		<p>
			<b>DWF_SM_96</b> - Analysis of the result element correctness

			<i>Description missing</i>
		</p>
		<p>
			<b>DWF_SM_97</b>
			Compare each configuration (one in the system, and other in the logical) and check if they contain the same functions.
		</p>
		<p>
			<b>DWF_SM_98</b>
			Compare each configuration (one in the pysical, and other in the logical) and check if they contain the same functions.
		</p>
		<p>
			<b>DWF_DC_34</b> - Analyzing the assurance of the FunctionalChain in the States/Modes.
			Analyzing the assurance of the FunctionalChain in the States/Modes. Validates on FunctionalChain. The functional chain is known as fully assured in a state/mode of a component, if all its functions allocated to this component are available in all configurations available in this state/mode
		</p>
		<p>
			<b>DWF_DC_35</b> - Analyzing the assurance of the FunctionalChains in the State/Mode.
			Analyzing the assurance of the FunctionalChains in the State/Mode. Validates on Mode. The functional chain is known as fully assured in a state/mode of a component, if all its functions allocated to this component are available in all configurations available in this state/mode
		</p>
		<p>
			<b>DWF_DC_36</b>
			Check if a included component has his port included in the other configuration.
		</p>
		<p>
			<b>DWF_DC_37</b>
			Check if an not or or operator have more than 1 values and if a not operator have only 1 value.
		</p>
	</body>
</html>